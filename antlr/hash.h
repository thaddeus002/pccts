/*
 * SOFTWARE RIGHTS
 *
 * We reserve no LEGAL rights to the Purdue Compiler Construction Tool
 * Set (PCCTS) -- PCCTS is in the public domain.  An individual or
 * company may do whatever they wish with source code distributed with
 * PCCTS or the code generated by PCCTS, including the incorporation of
 * PCCTS, or its output, into commerical software.
 *
 * We encourage users to develop software with PCCTS.  However, we do ask
 * that credit is given to us for developing PCCTS.  By "credit",
 * we mean that if you incorporate our source code into one of your
 * programs (commercial product, research project, or otherwise) that you
 * acknowledge this fact somewhere in the documentation, research report,
 * etc...  If you like PCCTS and have developed a nice tool with the
 * output, please mention that you developed it using PCCTS.  In
 * addition, we ask that this header remain intact in our source code.
 * As long as these guidelines are kept, we expect to continue enhancing
 * this system and expect to make other tools available as they are
 * completed.
 *
 * ANTLR 1.33
 * Terence Parr
 * Parr Research Corporation
 * with Purdue University and AHPCRC, University of Minnesota
 * 1989-2001
 */

/**
 * \file hash.h
 * \brief define hash table entries, sizes, hash function...
 *
 * Manage hash tables.
 * A HashTable is a collection of Entry classed by hash of str.
 *
 * The following functions are visible:
 *
 *    HashTable newHashTable();   Create and return initialized hash table
 *    Entry *hash_add(HashTable, char *, Entry *);
 *    Entry *hash_get(HashTable, char *);
 *    void  killHashTable(HashTable table);
 */

#ifndef __HASH_H_
#define __HASH_H_

        /* H a s h  T a b l e  S t u f f */

/** Number of 'Entry' in a hashtable, which is a table of 'Entry' */
#ifndef HashTableSize
#define HashTableSize 553
#endif

#ifndef StrTableSize
#define StrTableSize 1000000 /* all tokens, nonterminals, rexprs stored here */
#endif

/** Minimum hash table entry -- superclass */
typedef struct _entry {
    char *str;
    struct _entry *next;
} Entry;

#define newTermEntry(s)   (TermEntry *) newEntry(s, sizeof(TermEntry))
#define newRuleEntry(s)   (RuleEntry *) newEntry(s, sizeof(RuleEntry))
#define newCacheEntry(s)  (CacheEntry *) newEntry(s, sizeof(CacheEntry))
#define newLabelEntry(s)  (LabelEntry *) newEntry(s, sizeof(LabelEntry))
#define newSignalEntry(s) (SignalEntry *) newEntry(s, sizeof(SignalEntry))
#define newPredEntry(s)   (PredEntry *) newEntry(s, sizeof(PredEntry))


/**
 * A HashTable is a collection of Entry classed by hash of str.
 */
typedef Entry **HashTable;

/** Create and return initialized hash table */
HashTable newHashTable();


void killHashTable(HashTable table);

/**
 * Given a table, add 'rec' with key 'key' (add to front of list).
 * \return ptr to entry
 */
Entry *hash_add(HashTable table, char *key, Entry *rec);

/** Return ptr to 1st entry found in table under key (return NULL if none found) */
Entry *hash_get(HashTable table, const char *key);

/**
 * Given a string, this function allocates and returns a pointer to a
 * hash table record of size 'sz' whose "str" pointer is reset to a position
 * in the string table.
 * \param text the entry's text. must not be NULL.
 * \param sz size of the new Entry TODO what this means ?
 */
Entry *newEntry(const char *text, int sz);


#endif
