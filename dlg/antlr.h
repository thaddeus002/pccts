/*
 * SOFTWARE RIGHTS
 *
 * We reserve no LEGAL rights to the Purdue Compiler Construction Tool
 * Set (PCCTS) -- PCCTS is in the public domain.  An individual or
 * company may do whatever they wish with source code distributed with
 * PCCTS or the code generated by PCCTS, including the incorporation of
 * PCCTS, or its output, into commerical software.
 *
 * We encourage users to develop software with PCCTS.  However, we do ask
 * that credit is given to us for developing PCCTS.  By "credit",
 * we mean that if you incorporate our source code into one of your
 * programs (commercial product, research project, or otherwise) that you
 * acknowledge this fact somewhere in the documentation, research report,
 * etc...  If you like PCCTS and have developed a nice tool with the
 * output, please mention that you developed it using PCCTS.  In
 * addition, we ask that this header remain intact in our source code.
 * As long as these guidelines are kept, we expect to continue enhancing
 * this system and expect to make other tools available as they are
 * completed.
 *
 * ANTLR 1.33
 * Terence Parr
 * Parr Research Corporation
 * with Purdue University and AHPCRC, University of Minnesota
 * 1989-2000
 */

/**
 * \file antlr.h
 *
 * Define all of the stack setup and manipulation of $i, #i variables.
 *
 *  Notes:
 *    The type 'Attrib' must be defined before entry into this .h file.
 */


#ifndef ANTLR_H
#define ANTLR_H

#include <string.h>
#include "dlg_p.h" // for Attrib
#include "dlg_a.h"

typedef int ANTLRTokenType;
typedef unsigned char SetWordType;

typedef char ANTLRChar;

            /* G u e s s  S t u f f */


/* can make this a power of 2 for more efficient lookup */

#ifndef ZZLEXBUFSIZE
#define ZZLEXBUFSIZE  8000 /* MR22 raise from 2k to 8k */
#endif

#define zzOvfChk                            \
    if ( zzasp <= 0 )                                           \
    {                                                           \
        fprintf(stderr, zzStackOvfMsg, __FILE__, __LINE__);   \
        exit(1);                                               \
    }

#ifndef ZZA_STACKSIZE
#define ZZA_STACKSIZE 400
#endif

#ifndef zzfailed_pred
#define zzfailed_pred(_p,_hasuseraction,_useraction) \
    zzfailed_pred_action(_p,_hasuseraction,_useraction);
#endif

/*  MR23            Provide more control over failed predicate action
                    without any need for user to worry about guessing internals.
                    _hasuseraction == 0 => no user specified error action
                    _hasuseraction == 1 => user specified error action
*/

#ifndef zzfailed_pred_action
#define zzfailed_pred_action(_p,_hasuseraction,_useraction) \
    if (_hasuseraction) { _useraction } \
    else { fprintf(stderr, "semantic error; failed predicate: '%s'\n",_p); }
#endif


            /* S t a t e  S t u f f */

#define zzGUESS_BLOCK
#define zzGUESS
#define zzGUESS_FAIL
#define zzGUESS_DONE
#define zzNON_GUESS_MODE
#define zzGuessData

typedef struct _zzantlr_state {
      int asp;
      int ast_sp;
      int token;
      char text[ZZLEXBUFSIZE];
} zzantlr_state;

extern int zzGuessSeq;                      /* MR10 */
extern int zzSyntaxErrCount;                /* MR11 */
extern int zzLexErrCount;                   /* MR11 */

                 /* I n f i n i t e  L o o k a h e a d */


#define ANTLR_INFO  \
  Attrib zzempty_attr(void) {static Attrib a; return a;} \
  Attrib zzconstr_attr(int _tok, char *_text) \
    {Attrib a; zzcr_attr((&a),_tok,_text); return a;} \
  int zzasp=ZZA_STACKSIZE; \
  char zzStackOvfMsg[]="fatal: attrib/AST stack overflow %s(%d)!\n"; \
  Attrib zzaStack[ZZA_STACKSIZE]; \
    zzGuessData


#define zzenterANTLRs(s)                            \
        {static char zztoktext[ZZLEXBUFSIZE];   \
        zzlextext = zztoktext; zzrdstr( s ); zzgettok();}
#define zzenterANTLRf(f)              \
    {static char zztoktext[ZZLEXBUFSIZE]; \
    zzlextext = zztoktext; zzrdfunc( f ); zzgettok();}
#define zzenterANTLR(f)             \
    {static char zztoktext[ZZLEXBUFSIZE]; \
    zzlextext = zztoktext; zzrdstream( f ); zzgettok();}
#define zzleaveANTLR(f)
#define zzleaveANTLRf(f)
#define zzleaveANTLRs(f)


/* MR19 Paul D. Smith (psmith@baynetworks.com)
   Need to adjust AST stack pointer at exit.
   Referenced in ANTLRx macros.
*/


#define ANTLR(st, f)  zzbufsize = ZZLEXBUFSIZE; \
            zzenterANTLR(f);      \
            {                                            \
              zzBLOCK(zztasp1);                          \
              st; /* ++zzasp; Removed MR20 G. Hobbelt */     \
              /* MR20 G. Hobbelt. Kill the top' attribute (+AST stack corr.) */  \
              zzEXIT_ANTLR(zztasp1 + 1);                 \
            }                                            \
            zzleaveANTLR(f);

#define ANTLRm(st, f, _m) zzbufsize = ZZLEXBUFSIZE; \
            zzmode(_m);       \
            zzenterANTLR(f);      \
            {                                            \
              zzBLOCK(zztasp1);                          \
              st; /* ++zzasp; Removed MR20 G. Hobbelt */     \
              /* MR20 G. Hobbelt. Kill the top' attribute (+AST stack corr.) */  \
              zzEXIT_ANTLR(zztasp1 + 1);                 \
            }                                            \
            zzleaveANTLR(f);

#define ANTLRf(st, f) zzbufsize = ZZLEXBUFSIZE; \
            zzenterANTLRf(f);     \
            {                                            \
              zzBLOCK(zztasp1);                          \
              st; /* ++zzasp; Removed MR20 G. Hobbelt */     \
              /* MR20 G. Hobbelt. Kill the top' attribute (+AST stack corr.) */  \
              zzEXIT_ANTLR(zztasp1 + 1);                 \
            }                                            \
            zzleaveANTLRf(f);

#define ANTLRs(st, s)   zzbufsize = ZZLEXBUFSIZE; \
                        zzenterANTLRs(s);           \
            {                                            \
              zzBLOCK(zztasp1);                          \
              st; /* ++zzasp; Removed MR20 G. Hobbelt */     \
              /* MR20 G. Hobbelt. Kill the top' attribute (+AST stack corr.) */  \
              zzEXIT_ANTLR(zztasp1 + 1);                 \
            }                                            \
                        zzleaveANTLRs(s);

#define zztext    zzlextext


          /* A r g u m e n t  A c c e s s */

#define zzaCur      (zzaStack[zzasp])
#define zzaRet      (*zzaRetPtr)
#define zzaArg(v,n)   zzaStack[v-n]
#define zzMakeAttr    { zzNON_GUESS_MODE {zzOvfChk; --zzasp; zzcr_attr(&(zzaStack[zzasp]),LA(1),LATEXT(1));}}
#define zzMake0     { zzOvfChk; --zzasp;}
#define zzaPush(_v)   { zzOvfChk; zzaStack[--zzasp] = _v;}
#define zzREL(t)    zzasp=(t);    /* Restore state of stack */


#define zzsetmatch(_es,_tokclassErrset)           \
  if ( !_zzsetmatch(_es, &zzBadText, &zzMissText, &zzMissTok, &zzBadTok, &zzMissSet, _tokclassErrset) ) goto fail;

#define zzsetmatch_wsig(_es, handler)   \
  if ( !_zzsetmatch_wsig(_es) ) {_signal=MismatchedToken; goto handler;}

extern int _zzsetmatch(SetWordType *, char **, char **, int *, int *, SetWordType **, SetWordType *);
extern int _zzsetmatch_wsig(SetWordType *);

#define zzmatch(_t)             \
  if ( !_zzmatch(_t, &zzBadText, &zzMissText, &zzMissTok, &zzBadTok, &zzMissSet) ) goto fail;

#define zzmatch_wsig(_t,handler)      \
  if ( !_zzmatch_wsig(_t) ) {_signal=MismatchedToken; goto handler;}

extern int _zzmatch(int, char **, char **, int *, int *, SetWordType **);
extern int _zzmatch_wsig(int);

#define zzmatch_wdfltsig(_t,_f)     \
  if ( !_zzmatch_wdfltsig(_t,_f) ) _signal=MismatchedToken;
#define zzsetmatch_wdfltsig(tw,tt,wf)   \
  if ( !_zzsetmatch_wdfltsig(tw,tt,wf) ) _signal=MismatchedToken;

extern int _zzmatch_wdfltsig(int, SetWordType *);
extern int _zzsetmatch_wdfltsig(SetWordType *tokensWanted,
                int tokenTypeOfSet,
                SetWordType *whatFollows);

#define zzRULE    Attrib *zzaRetPtr = &(zzaStack[zzasp-1]); \
          int zzBadTok=0; char *zzBadText="";   \
          int zzErrk=1,zzpf=0;                \
                    zzTRACEdata \
          SetWordType *zzMissSet=NULL; int zzMissTok=0; char *zzMissText=""

#define zzBLOCK(i)  int i = zzasp - 1
#define zzEXIT(i) zzREL(i)
#define zzEXIT_ANTLR(i) zzREL(i)           /* [i_a] added as we want this for the ANTLRx() macros */
#define zzLOOP(i) zzREL(i)

#define zzCONSUME zzgettok();

#define NLA     zztoken
#define NLATEXT   zztext
#define LA(i)       zztoken
#define LATEXT(i)   zztext

           /* S t a n d a r d  S i g n a l s */

#define NoSignal      0
#define MismatchedToken   1
#define NoViableAlt     2
#define NoSemViableAlt    3

/* MR7  Allow more control over signalling                                  */
/*        by adding "Unwind" and "zzsetSignal"                              */

#define Unwind              4
#define zzsetSignal(newValue) *_retsignal=_signal=(newValue)
#define zzsuppressSignal *_retsignal=_signal=0
#define zzexportSignal    *_retsignal=_signal

           /* F u n c t i o n  T r a c i n g */

#define zzTRACEdata
#define zzTRACEIN(r)  zzTracePrevRuleName=zzTraceCurrentRuleName;zzTraceIn(r);
#define zzTRACEOUT(r) zzTraceOut(r);zzTraceCurrentRuleName=zzTracePrevRuleName;

/* MR19 zzchar_t additions */

#ifndef zzchar_t
#define zzchar_t char
#endif


        /* E x t e r n  D e f s */

extern Attrib zzempty_attr(void);
extern Attrib zzconstr_attr(int, char *);
extern void zzsyn(char *, int, char *, SetWordType *, int, int, char *);
extern int zzset_el(unsigned, SetWordType *);
extern int zzset_deg(SetWordType *);
extern void zzedecode(SetWordType *);
extern void zzresynch(SetWordType *, SetWordType);
extern void zzsave_antlr_state(zzantlr_state *);
extern void zzrestore_antlr_state(zzantlr_state *);
extern void zzfill_inf_look(void);
extern void zzconsumeUntil(SetWordType *st);                         /* MR7 */
extern void zzconsumeUntilToken(int t);                              /* MR7 */
extern void zzTraceIn(char * ruleName);                              /* MR10 */
extern void zzTraceOut(char * ruleName);                             /* MR10 */
extern int  zzTraceOption(int delta);                                /* MR10 */
extern int  zzTraceGuessOption(int delta);                           /* MR10 */
extern void zzTraceReset(void);                                      /* MR10 */
extern void zzTraceGuessFail(void);                                  /* MR10 */

        /* G l o b a l  V a r i a b l e s */

/* Define a parser; user should do a "#parser myname" in their grammar file */
/*extern struct pccts_parser zzparser;*/

int zztoken;
extern char zzStackOvfMsg[];
extern int zzasp;
extern Attrib zzaStack[];

#endif
