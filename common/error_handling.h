/*
 * SOFTWARE RIGHTS
 *
 * We reserve no LEGAL rights to the Purdue Compiler Construction Tool
 * Set (PCCTS) -- PCCTS is in the public domain.  An individual or
 * company may do whatever they wish with source code distributed with
 * PCCTS or the code generated by PCCTS, including the incorporation of
 * PCCTS, or its output, into commerical software.
 *
 * We encourage users to develop software with PCCTS.  However, we do ask
 * that credit is given to us for developing PCCTS.  By "credit",
 * we mean that if you incorporate our source code into one of your
 * programs (commercial product, research project, or otherwise) that you
 * acknowledge this fact somewhere in the documentation, research report,
 * etc...  If you like PCCTS and have developed a nice tool with the
 * output, please mention that you developed it using PCCTS.  In
 * addition, we ask that this header remain intact in our source code.
 * As long as these guidelines are kept, we expect to continue enhancing
 * this system and expect to make other tools available as they are
 * completed.
 *
 * ANTLR 1.33
 * Terence Parr
 * Parr Research Corporation
 * with Purdue University and AHPCRC, University of Minnesota
 * 1989-2000
 */

/**
 * \file error_handling.h
 *
 * Standard error handling mechanism
 *
 * Has grown to hold all kinds of stuff (error_handling.h is increasingly misnamed)
 */


#ifndef ERR_H
#define ERR_H

#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include <stdarg.h>


#define BSETWORDSIZE 8
#define BSETLOGWORDSIZE 3   /* SetWordType is 8bits */

#define BSETMODWORD(x) ((x) & (BSETWORDSIZE-1))   /* x % BSETWORDSIZE */
#define BSETDIVWORD(x) ((x) >> BSETLOGWORDSIZE)   /* x / BSETWORDSIZE */

/* This is not put into the global pccts_parser structure because it is
 * hidden and does not need to be saved during a "save state" operation
 */
/* maximum of 32 bits/unsigned int and must be 8 bits/byte */
static SetWordType bitmask[] = {
  0x00000001, 0x00000002, 0x00000004, 0x00000008,
  0x00000010, 0x00000020, 0x00000040, 0x00000080
};

int  zzGuessSeq=0;          /* MR10 */
int  zzSyntaxErrCount=0;    /* MR11 */
int  zzLexErrCount=0;       /* MR11 */

void zzresynch(SetWordType *wd,SetWordType mask)
{
  static int consumed = 1;

  /* if you enter here without having consumed a token from last resynch
   * force a token consumption.
   */
  if ( !consumed ) {zzCONSUME; consumed=1; return;}   /* MR10 */

  /* if current token is in resynch set, we've got what we wanted */
  if ( wd[LA(1)]&mask || LA(1) == zzEOF_TOKEN ) {consumed=0; return;}

  /* scan until we find something in the resynch set */
  while ( !(wd[LA(1)]&mask) && LA(1) != zzEOF_TOKEN ) {zzCONSUME;}
  consumed=1;
}

/* is b an element of set p? */
int zzset_el(unsigned b, SetWordType *p)
{
  return( p[BSETDIVWORD(b)] & bitmask[BSETMODWORD(b)] );
}

/*                                                                          */
/*  7-Apr-97 133MR1 for C++ and MR7 for C                                   */
/*         Change suggested by Eli Sternheim (eli@interhdl.com)           */
/*                                                                          */

void zzconsumeUntil(SetWordType *st)
{
    int     tmp;                                                     /* MR7 */
    while ( !zzset_el( (tmp=LA(1)), st) && tmp!=1 /* Eof */) {       /* MR7 */
        zzCONSUME;
    }   /* MR7 */
}

/*                                                                          */
/*  7-Apr-97 133MR1 for C++ and MR7 for C                                   */
/*         Change suggested by Eli Sternheim (eli@interhdl.com)           */
/*                                                                          */

void zzconsumeUntilToken(int t)
{
    int     tmp;                                                     /* MR7 */
    while ( (tmp=LA(1)) !=t && tmp!=1 /* Eof */) { zzCONSUME; }      /* MR7 */
}

/* input looks like:
 *    zzFAIL(k, e1, e2, ...,&zzMissSet,&zzMissText,&zzBadTok,&zzBadText)
 * where the zzMiss stuff is set here to the token that did not match
 * (and which set wasn't it a member of).
 */
void zzFAIL(int k, ...)
{
  static char text[ZZLEXBUFSIZE+1];
  SetWordType *f[1];
  SetWordType **miss_set;
  char **miss_text;
  int *bad_tok;
  char **bad_text;
  int *err_k;
  int i;
  va_list ap;
  va_start(ap, k);
  assert(k <= sizeof(f)/sizeof(f[0]));    /* MR20 G. Hobbelt */
  text[0] = '\0';
  for (i=1; i<=k; i++)  /* collect all lookahead sets */
  {
    f[i-1] = va_arg(ap, SetWordType *);
  }
  for (i=1; i<=k; i++)  /* look for offending token */
  {
    if ( i>1 ) strcat(text, " ");
    strcat(text, LATEXT(i));
    if ( !zzset_el((unsigned)LA(i), f[i-1]) ) break;
  }
  miss_set = va_arg(ap, SetWordType **);
  miss_text = va_arg(ap, char **);
  bad_tok = va_arg(ap, int *);
  bad_text = va_arg(ap, char **);
  err_k = va_arg(ap, int *);
  if ( i>k )
  {
    /* bad; lookahead is permutation that cannot be matched,
     * but, the ith token of lookahead is valid at the ith position
     * (The old LL sub 1 (k) versus LL(k) parsing technique)
     */
    *miss_set = NULL;
    *miss_text = zzlextext;
    *bad_tok = LA(1);
    *bad_text = LATEXT(1);
    *err_k = k;
    return;
  }
/*  fprintf(stderr, "%s not in %dth set\n", zztokens[LA(i)], i);*/
  *miss_set = f[i-1];
  *miss_text = text;
  *bad_tok = LA(i);
  *bad_text = LATEXT(i);
  if ( i==1 ) *err_k = 1;
  else *err_k = k;
}

void zzTraceGuessDone(zzantlr_state *state)
{
}

void zzsave_antlr_state(zzantlr_state *buf)
{
  buf->asp = zzasp;
  buf->token = zztoken;
  strcpy(buf->text, zzlextext);
}

void zzrestore_antlr_state(zzantlr_state *buf)
{
  zzasp = buf->asp;
  zztoken = buf->token;
  strcpy(zzlextext, buf->text);
}

void zzedecode(SetWordType *a)
{
  register SetWordType *p = a;
  register SetWordType *endp = &(p[zzSET_SIZE]);
  register unsigned e = 0;

  if ( zzset_deg(a)>1 ) fprintf(stderr, " {");
  do {
    register SetWordType t = *p;
    register SetWordType *b = &(bitmask[0]);
    do {
      if ( t & *b ) fprintf(stderr, " %s", zztokens[e]);
      e++;
    } while (++b < &(bitmask[sizeof(SetWordType)*8]));
  } while (++p < endp);
  if ( zzset_deg(a)>1 ) fprintf(stderr, " }");
}

int zzset_deg(SetWordType *a)
{
  /* Fast compute degree of a set... the number
     of elements present in the set.  Assumes
     that all word bits are used in the set
  */
  register SetWordType *p = a;
  register SetWordType *endp = &(a[zzSET_SIZE]);
  register int degree = 0;

  if ( a == NULL ) return 0;
  while ( p < endp )
  {
    register SetWordType t = *p;
    register SetWordType *b = &(bitmask[0]);
    do {
      if (t & *b) ++degree;
    } while (++b < &(bitmask[sizeof(SetWordType)*8]));
    p++;
  }

  return(degree);
}

int _zzmatch(int _t, char **zzBadText, char **zzMissText,
    int *zzMissTok, int *zzBadTok,
    SetWordType **zzMissSet)
{
  if ( LA(1)!=_t ) {
    *zzBadText = *zzMissText=LATEXT(1);
    *zzMissTok= _t; *zzBadTok=LA(1);
    *zzMissSet=NULL;
    return 0;
  }
  zzMakeAttr
  return 1;
}

int _zzmatch_wsig(int _t)
{
  if ( LA(1)!=_t ) return 0;
  zzMakeAttr
  return 1;
}


int _zzsetmatch(SetWordType *e, char **zzBadText, char **zzMissText,
      int *zzMissTok, int *zzBadTok,
      SetWordType **zzMissSet,
      SetWordType *zzTokclassErrset /* MR23 */)
{
  if ( !zzset_el((unsigned)LA(1), e) ) {
    *zzBadText = LATEXT(1); *zzMissText=NULL;
    *zzMissTok= 0; *zzBadTok=LA(1);
    *zzMissSet=zzTokclassErrset; /* MR23 */
    return 0;
  }
  zzMakeAttr           /* MR14 Ger Hobbelt (hobbelt@axa.nl) */
  return 1;
}

int _zzmatch_wdfltsig(int tokenWanted, SetWordType *whatFollows)
{
  if ( LA(1)!=tokenWanted )
  {
        zzSyntaxErrCount++;
    fprintf(stderr,
        "line %d: syntax error at \"%s\" missing %s\n",
        zzline,
        (LA(1)==zzEOF_TOKEN)?"<eof>":(char *)LATEXT(1),
        zztokens[tokenWanted]);
    zzconsumeUntil( whatFollows );
    return 0;
  }
  else {
    zzMakeAttr
    return 1;
  }
}

int _zzsetmatch_wdfltsig(SetWordType *tokensWanted,
           int tokenTypeOfSet,
           SetWordType *whatFollows)
{
  if ( !zzset_el((unsigned)LA(1), tokensWanted) )
  {
        zzSyntaxErrCount++;     /* MR11 */
    fprintf(stderr,
        "line %d: syntax error at \"%s\" missing %s\n",
        zzline,
        (LA(1)==zzEOF_TOKEN)?"<eof>":(char *)LATEXT(1),
        zztokens[tokenTypeOfSet]);
    zzconsumeUntil( whatFollows );
    return 0;
  }
  else {
    zzMakeAttr
    return 1;
  }
}

int _zzsetmatch_wsig(SetWordType *e)
{
  if ( !zzset_el((unsigned)LA(1), e) ) return 0;
  zzMakeAttr           /* MR14 Ger Hobbelt (hobbelt@axa.nl) */
  return 1;
}


void zzTraceReset()
{
}

void zzTraceGuessFail()
{
}

/* zzTraceOption:
     zero value turns off trace
*/

void zzTraceIn(char * rule)
{
  return;
}

void zzTraceOut(char * rule)
{
}

int zzTraceOption(int delta)
{
    return 0;
}

int zzTraceGuessOption(int delta)
{
    return 0;
}

#endif /* ERR_H */
